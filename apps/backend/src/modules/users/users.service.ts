/* eslint-disable @typescript-eslint/no-unsafe-argument */

/**
 * UsersService - Service handling user profile business logic
 *
 * NOTE: We disable some ESLint rules for this file,
 * because Supabase client returns `any` types without generated database types.
 * In production, it is recommended to use types generated by Supabase CLI.
 */
import {
  Injectable,
  InternalServerErrorException,
  Logger,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import {
  ProfileNotFoundException,
  LogoNotFoundException,
  InvalidFileTypeException,
  FileTooLargeException,
} from '../../common';
import { UserProfileResponseDto } from './dto/user-profile-response.dto';
import { UpdateUserProfileDto } from './dto/update-user-profile.dto';

/**
 * Interface representing a record from the user_profiles table
 * Field names correspond to database columns (snake_case)
 */
interface UserProfileRow {
  id: string;
  company_name: string | null;
  address: string | null;
  nip: string | null;
  bank_account: string | null;
  logo_url: string | null;
  invoice_number_format: string | null;
  invoice_number_counter: number | null;
  created_at: string;
  updated_at: string;
}

/**
 * UsersService - Service handling user profile business logic
 *
 * Services in NestJS contain all business logic.
 * Controllers should be "thin" - they only handle HTTP
 * and delegate work to services.
 *
 * This service communicates with Supabase:
 * - user_profiles table - user company data
 * - Supabase Storage (bucket: logos) - company logos
 * - Supabase Auth - user data (email)
 *
 * Pattern: We use service role key for full access
 * (bypasses Row Level Security), because authorization
 * is already handled by JwtAuthGuard.
 */
@Injectable()
export class UsersService {
  private supabase: SupabaseClient<any, any, any>;
  private readonly logger = new Logger(UsersService.name);

  // File upload configuration
  private readonly MAX_LOGO_SIZE: number;
  private readonly ALLOWED_MIME_TYPES: string[];
  private readonly STORAGE_BUCKET = 'logos';

  constructor(private readonly configService: ConfigService) {
    // Get Supabase configuration
    const supabaseUrl = this.configService.get<string>('supabase.url');
    const serviceRoleKey = this.configService.get<string>(
      'supabase.serviceRoleKey',
    );

    if (!supabaseUrl || !serviceRoleKey) {
      throw new Error('Supabase configuration is missing');
    }

    // Initialize Supabase client with service role key
    // Service role key bypasses RLS and gives full database access
    this.supabase = createClient(supabaseUrl, serviceRoleKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false,
      },
    });

    // Upload configuration from config file
    this.MAX_LOGO_SIZE =
      this.configService.get<number>('upload.maxLogoSizeBytes') ||
      2 * 1024 * 1024;
    this.ALLOWED_MIME_TYPES = this.configService.get<string[]>(
      'upload.allowedMimeTypes',
    ) || ['image/png', 'image/jpeg'];
  }

  /**
   * Gets user profile
   *
   * Combines data from two sources:
   * 1. auth.users - user email
   * 2. user_profiles - company data
   *
   * @param userId - User ID (from JWT token)
   * @returns UserProfileResponseDto - user profile
   * @throws ProfileNotFoundException - when profile does not exist
   */
  async getProfile(userId: string): Promise<UserProfileResponseDto> {
    this.logger.debug(`Getting profile for user: ${userId}`);

    // Pobierz dane z tabeli user_profiles
    const { data: profile, error: profileError } = await this.supabase
      .from('user_profiles')
      .select('*')
      .eq('id', userId)
      .single();

    if (profileError || !profile) {
      this.logger.warn(`Profile not found for user: ${userId}`);
      throw new ProfileNotFoundException();
    }

    // Pobierz email z Supabase Auth
    const { data: userData, error: userError } =
      await this.supabase.auth.admin.getUserById(userId);

    if (userError || !userData.user) {
      this.logger.error(`Failed to get user data: ${userError?.message}`);
      throw new ProfileNotFoundException();
    }

    // Map database data to DTO (snake_case → camelCase)
    return this.mapToProfileDto(
      profile as UserProfileRow,
      userData.user.email!,
    );
  }

  /**
   * Updates user profile
   *
   * Updates only fields passed in the DTO.
   * Undefined fields are skipped.
   *
   * @param userId - User ID
   * @param dto - data to update
   * @returns UserProfileResponseDto - updated profile
   */
  async updateProfile(
    userId: string,
    dto: UpdateUserProfileDto,
  ): Promise<UserProfileResponseDto> {
    this.logger.debug(`Updating profile for user: ${userId}`);

    // Map DTO to database format (camelCase → snake_case)
    // Using Object.entries to skip undefined fields
    const updateData: Record<string, unknown> = {};

    if (dto.companyName !== undefined) {
      updateData.company_name = dto.companyName;
    }
    if (dto.address !== undefined) {
      updateData.address = dto.address;
    }
    if (dto.nip !== undefined) {
      updateData.nip = dto.nip;
    }
    if (dto.bankAccount !== undefined) {
      updateData.bank_account = dto.bankAccount;
    }
    if (dto.invoiceNumberFormat !== undefined) {
      updateData.invoice_number_format = dto.invoiceNumberFormat;
    }

    // Add update timestamp
    updateData.updated_at = new Date().toISOString();

    // Execute update
    const { error: updateError } = await this.supabase
      .from('user_profiles')
      .update(updateData)
      .eq('id', userId);

    if (updateError) {
      this.logger.error(`Failed to update profile: ${updateError.message}`);
      throw new InternalServerErrorException('Failed to update profile');
    }

    // Return updated profile
    return this.getProfile(userId);
  }

  /**
   * Uploads company logo
   *
   * Process:
   * 1. File type and size validation
   * 2. Delete old logo (if exists)
   * 3. Upload new logo to Supabase Storage
   * 4. Update URL in database
   *
   * File naming: logos/{userId}/logo.{timestamp}.{extension}
   * Timestamp prevents caching issues.
   *
   * @param userId - User ID
   * @param file - file to upload (from multer)
   * @returns { logoUrl: string } - URL to new logo
   */
  async uploadLogo(
    userId: string,
    file: Express.Multer.File,
  ): Promise<{ logoUrl: string }> {
    this.logger.debug(`Uploading logo for user: ${userId}`);

    // 1. Validate file type
    if (!this.ALLOWED_MIME_TYPES.includes(file.mimetype)) {
      throw new InvalidFileTypeException();
    }

    // 2. Validate file size
    if (file.size > this.MAX_LOGO_SIZE) {
      throw new FileTooLargeException();
    }

    // 3. Get current profile to check for old logo
    const { data: profile } = await this.supabase
      .from('user_profiles')
      .select('logo_url')
      .eq('id', userId)
      .single();

    // 4. Delete old logo if exists
    if (profile?.logo_url) {
      await this.deleteLogoFile(profile.logo_url);
    }

    // 5. Prepare path for new file
    const extension = file.mimetype === 'image/png' ? 'png' : 'jpg';
    const timestamp = Date.now();
    const filePath = `${userId}/logo.${timestamp}.${extension}`;

    // 6. Upload to Supabase Storage
    const { error: uploadError } = await this.supabase.storage
      .from(this.STORAGE_BUCKET)
      .upload(filePath, file.buffer, {
        contentType: file.mimetype,
        upsert: true, // Overwrite if exists
      });

    if (uploadError) {
      this.logger.error(`Failed to upload logo: ${uploadError.message}`);
      throw new InternalServerErrorException('Failed to upload logo');
    }

    // 7. Get public URL
    const { data: urlData } = this.supabase.storage
      .from(this.STORAGE_BUCKET)
      .getPublicUrl(filePath);

    const logoUrl = urlData.publicUrl;

    // 8. Update URL in database
    const { error: updateError } = await this.supabase
      .from('user_profiles')
      .update({
        logo_url: logoUrl,
        updated_at: new Date().toISOString(),
      })
      .eq('id', userId);

    if (updateError) {
      this.logger.error(`Failed to update logo URL: ${updateError.message}`);
      // Try to delete uploaded file
      await this.supabase.storage.from(this.STORAGE_BUCKET).remove([filePath]);
      throw new InternalServerErrorException('Failed to update logo URL');
    }

    this.logger.log(`Logo uploaded successfully for user: ${userId}`);
    return { logoUrl };
  }

  /**
   * Deletes company logo
   *
   * Process:
   * 1. Check if logo exists
   * 2. Delete file from Storage
   * 3. Clear URL in database
   *
   * @param userId - User ID
   * @returns { message: string } - success message
   * @throws LogoNotFoundException - when logo does not exist
   */
  async deleteLogo(userId: string): Promise<{ message: string }> {
    this.logger.debug(`Deleting logo for user: ${userId}`);

    // 1. Get current logo URL
    const { data: profile, error: selectError } = await this.supabase
      .from('user_profiles')
      .select('logo_url')
      .eq('id', userId)
      .single();

    if (selectError) {
      this.logger.error(`Failed to get profile: ${selectError.message}`);
      throw new ProfileNotFoundException();
    }

    // 2. Check if logo exists
    if (!profile?.logo_url) {
      throw new LogoNotFoundException();
    }

    // 3. Delete file from Storage
    await this.deleteLogoFile(profile.logo_url);

    // 4. Clear URL in database
    const { error: updateError } = await this.supabase
      .from('user_profiles')
      .update({
        logo_url: null,
        updated_at: new Date().toISOString(),
      })
      .eq('id', userId);

    if (updateError) {
      this.logger.error(`Failed to clear logo URL: ${updateError.message}`);
      throw new InternalServerErrorException('Failed to delete logo');
    }

    this.logger.log(`Logo deleted successfully for user: ${userId}`);
    return { message: 'Logo successfully deleted' };
  }

  /**
   * Helper method to delete logo file from Storage
   *
   * Extracts file path from full URL and deletes it.
   *
   * @param logoUrl - full URL to logo
   */
  private async deleteLogoFile(logoUrl: string): Promise<void> {
    try {
      // URL format: https://xxx.supabase.co/storage/v1/object/public/logos/userId/filename
      // We need to extract: userId/filename
      const url = new URL(logoUrl);
      const pathParts = url.pathname.split('/');

      // Find 'logos' index and take everything after it
      const bucketIndex = pathParts.indexOf(this.STORAGE_BUCKET);
      if (bucketIndex === -1) {
        this.logger.warn(`Invalid logo URL format: ${logoUrl}`);
        return;
      }

      const filePath = pathParts.slice(bucketIndex + 1).join('/');

      const { error } = await this.supabase.storage
        .from(this.STORAGE_BUCKET)
        .remove([filePath]);

      if (error) {
        this.logger.warn(`Failed to delete old logo: ${error.message}`);
        // Don't throw error - old logo may no longer exist
      }
    } catch {
      this.logger.warn(`Error parsing logo URL: ${logoUrl}`);
      // Don't throw error - this is just cleanup
    }
  }

  /**
   * Maps database record to DTO
   *
   * Converts snake_case to camelCase and adds email.
   *
   * @param profile - record from user_profiles table
   * @param email - user email from auth.users
   * @returns UserProfileResponseDto
   */
  private mapToProfileDto(
    profile: UserProfileRow,
    email: string,
  ): UserProfileResponseDto {
    return {
      id: profile.id,
      email,
      companyName: profile.company_name,
      address: profile.address,
      nip: profile.nip,
      bankAccount: profile.bank_account,
      logoUrl: profile.logo_url,
      invoiceNumberFormat: profile.invoice_number_format || 'FV/{YYYY}/{NNN}',
      invoiceNumberCounter: profile.invoice_number_counter || 0,
      createdAt: new Date(profile.created_at),
      updatedAt: new Date(profile.updated_at),
    };
  }
}
